---
name: tool-design
description: 当用户要求“设计助手工具”、“创建工具描述”、“减少工具复杂性”、“实现 MCP 工具”，或提到工具整合、架构简化、工具命名规范或助手-工具接口时使用此技能。
---

# 助手工具设计 (Tool Design for Agents)

工具是助手与世界交互的主要机制。它们定义了确定性系统与非确定性助手之间的合同。与专门为开发者设计的传统软件 API 不同，工具 API 必须为语言模型设计，这些模型需要进行意图推理、推断参数值，并从自然语言请求中生成调用。糟糕的工具设计会产生任何提示词工程都无法修复的失败模式。有效的工具设计遵循特定的原则，这些原则考虑了助手如何感知和使用工具。

## 何时激活

在以下情况激活此技能：
- 为助手系统创建新工具
- 调试与工具相关的失败或误用
- 优化现有工具集以获得更好的助手性能
- 从头开始设计工具 API
- 评估第三方工具以进行助手集成
- 在代码库中标准化工具规范

## 核心概念

工具是确定性系统与非确定性助手之间的合同。**整合原则**指出，如果人类工程师无法明确说明在特定情况下应该使用哪个工具，那么就不能指望助手能做得更好。有效的工具描述是塑造助手行为的提示词工程。

关键原则包括：清晰的描述（回答“是什么”、“何时用”和“返回什么”）；平衡完整性和 Token 效率的响应格式；能够实现故障恢复的错误消息；以及减少认知负荷的一致规范。

## 详细主题

### 工具-助手接口

**工具即合同**
工具是确定性系统与非确定性助手之间的合同。人类调用 API 时，他们理解合同并发出适当的请求。助手必须从描述中推断合同，并生成符合预期格式的调用。

这种根本差异需要重新思考 API 设计。合同必须是明确的，示例必须说明预期模式，错误消息必须引导纠正。工具定义中的每一个歧义都会成为潜在的失败模式。

**工具描述即提示词**
工具描述被加载到助手的上下文中，并共同引导其行为。描述不仅仅是文档——它们是塑造分析工具使用方式的提示词工程。

糟糕的描述（如“搜索数据库”配合晦涩的参数名）会迫使助手进行猜测。优化的描述包括使用背景、示例和默认值。描述应回答：工具做什么、何时使用它、以及它产生什么。

**命名空间和组织**
随着工具集合的增长，组织变得至关重要。命名空间通过共同的前缀将相关工具组合在一起，帮助助手在正确的时间选择合适的工具。

命名空间在功能之间创建了清晰的边界。当助手需要数据库信息时，它会路由到数据库命名空间。当它需要网页搜索时，它会路由到网络命名空间。

### 整合原则 (The Consolidation Principle)

**单一综合工具**
整合原则指出，如果人类工程师无法明确说明在特定情况下应该使用哪个工具，那么就不能指望助手能做得更好。这导致人们更倾向于使用单一的综合工具，而不是多个狭窄的工具。

与其实现 `list_users`、`list_events` 和 `create_event`，不如实现一个 `schedule_event` 工具，用于查找空闲时间并进行预约。综合工具在内部处理完整的流程，而不是要求助手链接多个调用。

**为什么整合有效**
助手的上下文和注意力是有限的。工具集中的每个工具都在工具选择阶段竞争注意力。每个工具都会增加描述 Token，消耗上下文预算。重叠的功能会造成工具选择的歧义。

整合通过消除冗余描述来减少 Token 消耗。它通过让一个工具覆盖每个工作流来消除歧义。它通过缩小有效工具集来降低工具选择的复杂性。

**何时不整合**
整合并非普遍适用。具有根本不同行为的工具应保持独立。在不同上下文中使用的工具受益于分离。可能被独立调用的工具不应被人为捆绑。

### 架构简化 (Architectural Reduction)

将整合原则推向逻辑极致，就会产生架构简化：移除大多数专用工具，转而使用原始的、通用的能力。生产实践证明，这种方法优于复杂的多工具架构。

**文件系统助手模式**
与其为数据探索、Schema 查找和查询验证构建自定义工具，不如通过单一的命令执行工具提供直接的文件系统访问。助手使用标准的 Unix 工具（grep, cat, find, ls）来探索、理解和操作系统。

这种方法有效的原因是：
1. 文件系统是经过验证的抽象，模型对其有深刻理解
2. 标准工具具有可预测、文档齐全的行为
3. 助手可以灵活地链接原子操作，而不是被限制在预定义的工作流中
4. 文件中良好的文档取代了对摘要工具的需求

**简化优于复杂性的情况**
简化在以下情况有效：
- 您的数据层文档齐全且结构一致
- 模型具有足够的推理能力来应对复杂性
- 您的专用工具是在限制而非赋能模型
- 您在维护脚手架上花费的时间超过了改进结果的时间

简化在以下情况失败：
- 您的底层数据混乱、不一致或文档匮乏
- 该领域需要模型缺乏的专业知识
- 安全约束需要限制助手的操作
- 操作确实非常复杂且受益于结构化工作流

**停止限制推理**
一个常见的前期反模式是构建工具来“保护”模型免受复杂性的影响。预过滤上下文、限制选项、将交互包裹在验证逻辑中。随着模型的改进，这些护栏往往会变成累赘。

需要思考的问题是：您的工具是在赋能新能力，还是在限制模型原本可以自行处理的推理？

**为未来的模型构建**
模型的提升速度快于工具的更新速度。为今天的模型优化的架构对于明天的模型可能过于受限。构建能够受益于模型改进的最简架构，而不是锁定当前局限性的复杂架构。

参见 [架构简化案例研究](./references/architectural_reduction_zh.md) 获取生产证据。

### 工具描述工程

**描述结构**
有效的工具描述回答四个问题：

1. **工具做什么？** 清晰、具体的描述。避免使用“有助于”、“可用于”等模糊语言。明确陈述工具完成的任务。
2. **何时应该使用？** 特定的触发条件和上下文。包括直接触发（“用户询问价格”）和间接信号（“需要当前市场汇率”）。
3. **接受什么输入？** 包含类型、约束和默认值的参数描述。解释每个参数控制什么。
4. **返回什么？** 输出格式和结构。包括成功响应和错误条件的示例。

**默认参数选择**
默认值应反映常见用例。它们通过消除不必要的参数指定来减轻助手负担，并防止因遗漏参数而导致的错误。

### 响应格式优化

工具响应的大小显著影响上下文使用。实现响应格式选项可让助手控制详细程度。

**简明格式 (Concise)** 仅返回基本参数，适用于确认或基本信息。**详细格式 (Detailed)** 返回包含所有参数的完整对象，适用于决策需要完整上下文的情况。

在工具描述中加入关于何时使用每种格式的指导。助手会学会根据任务要求选择适当的格式。

### 错误消息设计

错误消息服务于两类受众：调试问题的开发者和从失败中恢复的助手。对于助手来说，错误消息必须是**可操作的**。它们必须告诉助手哪里出了错以及如何纠正。

设计能够实现恢复的错误消息。对于可重试的错误，包含重试指导。对于输入错误，包含纠正后的格式。对于缺失数据，包含所需的内容。

### 工具定义 Schema

在所有工具中使用一致的 Schema。建立命名规范：工具名采用“动词-名词”模式，各工具间参数名一致，返回参数名一致。

### 工具集合设计

研究表明，工具描述的重叠会导致模型困惑。更多的工具并不总是带来更好的结果。一个合理的指导原则是大多数应用采用 10-20 个工具。如果需要更多，请使用命名空间来创建逻辑分组。

实现帮助助手选择正确工具的机制：工具分组、基于示例的选择，以及通过顶层工具路由到专门子工具的层级结构。

### MCP 工具命名要求

在使用 MCP (Model Context Protocol) 工具时，始终使用**全限定工具名**以避免“找不到工具”的错误。

格式：`ServerName:tool_name`

```python
# 正确：全限定名称
"Use the BigQuery:bigquery_schema tool to retrieve table schemas."
"Use the GitHub:create_issue tool to create issues."

# 错误：非限定名称
"Use the bigquery_schema tool..."  # 在存在多个服务器时可能会失败
```

如果没有服务器前缀，助手可能无法定位工具，尤其是在有多个 MCP 服务器可用时。建立包含服务器背景的所有工具引用规范。

### 使用助手优化工具

Claude 可以优化自己的工具。当给定一个工具并观察到失败模式时，它可以诊断问题并建议改进。生产测试显示，这种方法通过帮助未来的助手避免错误，使任务完成时间缩短了 40%。

**工具测试助手模式 (The Tool-Testing Agent Pattern)**:

```python
def optimize_tool_description(tool_spec, failure_examples):
    """
    使用助手分析工具失败并改进描述。
    
    流程：
    1. 助手尝试在各种任务中使用工具
    2. 收集失败模式和摩擦点
    3. 助手分析失败并提出改进建议
    4. 针对相同任务测试改进后的描述
    """
    prompt = f"""
    分析此工具规范和观察到的失败案例。
    
    工具：{tool_spec}
    
    观察到的失败：
    {failure_examples}
    
    确定：
    1. 助手在使用此工具时失败的原因
    2. 描述中缺失了哪些信息
    3. 哪些歧义导致了错误使用
    
    提议一个解决这些问题的改进后的工具描述。
    """
    
    return get_agent_response(prompt)
```

这创建了一个反馈闭环：助手使用工具产生失败数据，助手再利用这些数据改进工具描述，从而减少未来的失败。

### 测试工具设计

根据标准评估工具设计：明确性、完整性、可恢复性、效率和一致性。通过展示代表性的助手请求并评估生成的工具调用来测试工具。

## 实践指南

### 应避免的反模式

*   **模糊描述**：“在数据库中搜索客户信息”留下了太多未解之问。
*   **晦涩的参数名**：名为 x, val 或 param1 的参数迫使助手猜测含义。
*   **缺失错误处理**：因通用错误而失败的工具无法提供恢复指导。
*   **命名不一致**：在某些工具中使用 `id`，在其他工具中使用 `identifier`，在另一些工具中使用 `customer_id`，会造成混淆。

### 工具选择框架

在设计工具集时：
1. 确定助手必须完成的独特工作流
2. 将相关操作组合成综合工具
3. 确保每个工具都有清晰、明确的用途
4. 记录错误情况和恢复路径
5. 使用真实的助手交互进行测试

## 示例

**示例 1：设计良好的工具**
```python
def get_customer(customer_id: str, format: str = "concise"):
    """
    通过 ID 获取客户信息。
    
    使用场景：
    - 用户询问特定客户详情
    - 决策时需要客户背景信息
    - 验证客户身份
    
    参数：
        customer_id: 格式为 "CUST-######" (例如 "CUST-000001")
        format: "concise" 获取关键参数，"detailed" 获取完整记录
    
    返回：
        包含请求参数的 Customer 对象
    
    错误：
        NOT_FOUND: 客户 ID 未找到
        INVALID_FORMAT: ID 必须符合 CUST-###### 模式
    """
```

**示例 2：糟糕的工具设计**

该示例展示了几个工具设计反模式：

```python
def search(query):
    """搜索数据库。"""
    pass
```

**此设计的问题：**

1. **名称模糊**：“search” 是歧义的——搜索什么，出于什么目的？
2. **缺失参数**：什么数据库？查询应该采用什么格式？
3. **无返回描述**：此函数返回什么？列表？字符串？错误处理？
4. **无使用背景**：助手何时应该使用此工具而非其他工具？
5. **无错误处理**：如果数据库不可用会发生什么？

**失败模式：**
- 助手在应该使用更具体工具时调用此工具
- 助手无法确定正确的查询格式
- 助手无法解释结果
- 助手无法从失败中恢复

## 指南板

1. 编写回答“是什么”、“何时用”和“返回什么”的描述
2. 使用整合原则减少歧义
3. 实现响应格式选项以提高 Token 效率
4. 为助手恢复设计错误消息
5. 建立并遵循一致的命名规范
6. 限制工具数量并使用命名空间进行组织
7. 使用真实的助手交互测试工具设计
8. 根据观察到的失败模式进行迭代
9. 质疑每个工具是赋能还是限制了模型
10. 优先选择原始的通用工具，而非专用的包装器
11. 投入精力提高文档质量，而非工具的复杂性
12. 构建可受益于模型提升的最简架构

## 集成

此技能连接至：
- context-fundamentals - 工具如何与上下文交互
- multi-agent-patterns - 每个助手的专用工具
- evaluation - 评估工具效能

## 参考资料

内部参考：
- [最佳实践参考](./references/best_practices_zh.md) - 详细的工具设计指南
- [架构简化案例研究](./references/architectural_reduction_zh.md) - 工具极简主义的生产证据

此集合中的相关技能：
- context-fundamentals - 工具上下文交互
- evaluation - 工具测试模式

外部资源：
- MCP (Model Context Protocol) 文档
- 框架工具规范
- 针对助手的 API 设计最佳实践
- Vercel d0 助手架构案例研究

---

## 技能元数据

**创建日期**: 2025-12-20
**更新日期**: 2025-12-23
**作者**: Agent Skills for Context Engineering 贡献者
**版本**: 1.1.0
