---
name: multi-agent-patterns
description: 当用户要求“设计多智能体系统（MAS）”、“实现主管模式”、“创建群集（swarm）架构”、“协调多个助手”，或提到多助手模式、上下文隔离、助手交接、子助手或并行助手执行时，应使用此技巧。
---

# 多助手架构模式 (Multi-Agent Architecture Patterns)

多助手架构通过将工作分配给多个语言模型实例来实现，每个实例都有自己的上下文窗口。设计的核心洞察是：**子助手（Sub-agents）的主要存在目的是隔离上下文，而不是进行拟人化的角色分工。**

## 何时激活

在以下情况下启用此技能：
- 单个助手的上下文限制制约了任务复杂性
- 任务可以自然分解为并行的子任务
- 不同的子任务需要不同的工具集或系统提示词
- 需要构建同时处理多个领域的系统
- 需要扩展助手的推理能力，使其超越单一上下文的限制

## 核心概念

多助手系统通过“分布式”处理来解决上下文受限问题。目前主要有三种模式：
1.  **主管/编排者 (Supervisor/Orchestrator)**：中央控制模式。
2.  **点对点/群集 (Peer-to-Peer/Swarm)**：灵活交接模式。
3.  **分层模式 (Hierarchical)**：分层抽象模式。

有效的 MAS 需要显式的协调协议、避免由于盲从（sycophancy）导致的共识陷阱，并关注瓶颈、发散和错误传播等失效模式。

## 详细主题

### 为什么需要多助手架构？
**解决上下文瓶颈**：随着任务变复杂，单个助手的上下文会充斥着历史记录、文档和工具输出，导致“迷失在中间”和注意力稀缺。多助手架构通过将工作拆分到多个干净的上下文窗口来解决此问题。

**并行化 (Parallelization)**：单个助手通常按顺序执行子任务。多助手架构允许分配专用助手同时工作，将总时间从“所有子任务之和”降至“最长子任务的耗时”。

**由于隔离带来的专门化**：不同的子任务受益于不同的配置。主管引导请求到专门助手，每个助手只需携带其领域所需的精简内容。

### 架构模式详解

#### 1. 主管/编排者模式 (Supervisor/Orchestrator)
中央助手分解目标，分发任务给 Specialist 并汇总结果。
- **优点**：严格的工作流控制，易于加入“人工在环（human-in-the-loop）”。
- **缺点**：主管可能成为上下文瓶颈；存在“传口令游戏（telephone game）”问题，主管可能错误地转述子助手的响应。
- **解决方案**：实现消息转发（forwarding）机制，允许子助手在必要时直接回复用户。

#### 2. 点对点/群集模式 (Swarm)
没有中央控制，助手通过 Handoff 机制互相转移控制权。
- **优点**：无单点故障，适合广度探索，能产生涌现的问题处理行为。
- **缺点**：协调复杂，存在发散风险。

#### 3. 分层模式 (Hierarchical)
分为战略层、规划层和执行层，逐层分解。
- **优点**：关注点分离，不同层级使用不同的上下文结构。
- **缺点**：层级间的协调开销大。

### 上下文隔离是设计原则
MAS 的主要目的是**上下文隔离**。
- **全上下文委派**：适用于复杂任务，子助手需要理解全局。
- **指令传递**：主管仅通过函数调用向子助手传递特定指令，保持极致轻量。
- **文件系统记忆**：各助手通过读写同一个外部存储来协调，避免由于互相通信导致的上下文膨胀。

## 准则

1. 将**上下文隔离**视为 MAS 的主要收益。
2. 根据协调需求而非“组织机构类比”来选择架构。
3. 实现显式的带状态传递的交接协议。
4. 使用加权投票或辩论协议以达成共识。
5. 监控主管瓶颈并实施 Checkpointing。
6. 在助手间传递输出前进行验证。
7. 设置生存时间（TTL）限制以防止死循环。

## 技巧元数据

**创建日期**: 2025-12-20
**作者**: Agent Skills for Context Engineering 贡献者
**版本**: 1.0.0
